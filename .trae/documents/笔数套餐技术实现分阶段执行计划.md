# 笔数套餐技术实现分阶段执行计划

## 1. 项目概述

笔数套餐是一种按交易笔数计费的能量代理服务技术实现方案。本文档基于《笔数套餐完整业务流程分析》，提供详细的技术架构设计、实现方案和分阶段执行计划，确保系统的稳定性、可扩展性和可维护性。

### 1.1 核心技术目标
- 实现分批能量代理机制，支持按笔数精确控制
- 建立实时能量使用监听系统，确保及时响应
- 构建24小时占费机制，保障资源合理利用
- 提供完整的订单生命周期管理
- 确保系统高可用性和数据一致性

### 1.2 技术约束
- 基于现有TRON能量租赁系统架构
- 保持与现有订单系统的兼容性
- 遵循项目现有的技术栈和编码规范
- 确保数据库操作的事务性和一致性

## 2. 技术架构设计

### 2.1 整体系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户交互层                                │
├─────────────────────────────────────────────────────────────┤
│  Telegram Bot API  │  管理后台界面  │  移动端接口(未来)     │
└─────────────┬───────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────┐
│                    应用服务层                                │
├─────────────────────────────────────────────────────────────┤
│ OrderCreation │ PaymentMonitor │ BatchDelegation │ Notification │
│    Service    │    Service     │   Controller    │   Service    │
├─────────────────────────────────────────────────────────────┤
│ EnergyUsage   │  DailyFee     │ MessageFormat   │ AddressValid │
│ MonitorService│   Service     │   Generator     │   Service    │
└─────────────┬───────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────┐
│                    数据访问层                                │
├─────────────────────────────────────────────────────────────┤
│  OrderRepository │ EnergyUsageRepository │ ConfigRepository  │
└─────────────┬───────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────┐
│                    数据存储层                                │
├─────────────────────────────────────────────────────────────┤
│    Orders表    │ Energy_Usage_Logs表 │ Price_Configs表     │
│ (扩展字段)     │    (新增表)         │  (扩展字段)         │
└─────────────┬───────────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────────┐
│                    外部服务层                                │
├─────────────────────────────────────────────────────────────┤
│    TRON网络API    │    能量池账户    │    Redis缓存        │
│   (实时查询)      │   (代理执行)     │   (状态缓存)        │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心服务分层设计

#### 2.2.1 控制器层 (Controller Layer)
- **TransactionPackageController**: 处理笔数套餐相关的HTTP请求
- **BatchDelegationController**: 管理分批代理逻辑
- **EnergyMonitorController**: 处理能量监听相关操作

#### 2.2.2 服务层 (Service Layer)
- **OrderCreationService**: 订单创建和管理
- **EnergyUsageMonitorService**: 能量使用监听
- **DailyFeeService**: 占费检测和执行
- **BatchDelegationService**: 分批代理执行
- **NotificationService**: 消息通知服务

#### 2.2.3 数据访问层 (Repository Layer)
- **OrderRepository**: 订单数据操作
- **EnergyUsageLogRepository**: 能量使用记录操作
- **PriceConfigRepository**: 价格配置操作

### 2.3 数据流设计

```
用户选择套餐 → 地址验证 → 订单创建 → 支付监听 → 首次代理
     ↓
能量使用监听 → 检测消耗 → 触发代理 → 更新状态 → 通知用户
     ↓
占费检测 → 24小时判断 → 扣除笔数 → 记录日志 → 状态更新
```

## 3. 数据库设计

### 3.1 Orders表扩展设计

```sql
-- 扩展现有orders表，添加笔数套餐相关字段
ALTER TABLE orders ADD COLUMN IF NOT EXISTS transaction_count INTEGER DEFAULT 1 
  COMMENT '购买的总交易笔数';
ALTER TABLE orders ADD COLUMN IF NOT EXISTS used_transactions INTEGER DEFAULT 0 
  COMMENT '已使用的交易笔数';
ALTER TABLE orders ADD COLUMN IF NOT EXISTS remaining_transactions INTEGER DEFAULT 0 
  COMMENT '剩余可用交易笔数';
ALTER TABLE orders ADD COLUMN IF NOT EXISTS last_energy_usage_time TIMESTAMP WITH TIME ZONE 
  COMMENT '最后一次能量使用时间';
ALTER TABLE orders ADD COLUMN IF NOT EXISTS next_delegation_time TIMESTAMP WITH TIME ZONE 
  COMMENT '下次代理检查时间';
ALTER TABLE orders ADD COLUMN IF NOT EXISTS daily_fee_last_check TIMESTAMP WITH TIME ZONE 
  COMMENT '最后一次占费检查时间';

-- 添加索引优化查询性能
CREATE INDEX IF NOT EXISTS idx_orders_transaction_package 
  ON orders(order_type, status, remaining_transactions) 
  WHERE order_type = 'transaction_package';
CREATE INDEX IF NOT EXISTS idx_orders_energy_usage_time 
  ON orders(last_energy_usage_time) 
  WHERE order_type = 'transaction_package';
CREATE INDEX IF NOT EXISTS idx_orders_daily_fee_check 
  ON orders(daily_fee_last_check) 
  WHERE order_type = 'transaction_package';
```

### 3.2 Energy_Usage_Logs表设计

```sql
-- 创建能量使用记录表
CREATE TABLE IF NOT EXISTS energy_usage_logs (
  id SERIAL PRIMARY KEY,
  order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  user_address VARCHAR(34) NOT NULL COMMENT 'TRON地址',
  energy_before INTEGER NOT NULL COMMENT '使用前能量值',
  energy_after INTEGER NOT NULL COMMENT '使用后能量值',
  energy_consumed INTEGER NOT NULL COMMENT '消耗的能量',
  transaction_hash VARCHAR(64) COMMENT '触发的交易哈希',
  usage_time TIMESTAMP WITH TIME ZONE DEFAULT NOW() COMMENT '使用时间',
  detection_time TIMESTAMP WITH TIME ZONE DEFAULT NOW() COMMENT '检测时间',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 添加索引
CREATE INDEX idx_energy_usage_logs_order_id ON energy_usage_logs(order_id);
CREATE INDEX idx_energy_usage_logs_user_address ON energy_usage_logs(user_address);
CREATE INDEX idx_energy_usage_logs_usage_time ON energy_usage_logs(usage_time DESC);
CREATE INDEX idx_energy_usage_logs_detection_time ON energy_usage_logs(detection_time DESC);

-- 添加表注释
COMMENT ON TABLE energy_usage_logs IS '能量使用记录表，记录用户每次能量消耗详情';
```

### 3.3 Daily_Fee_Logs表设计

```sql
-- 创建占费记录表
CREATE TABLE IF NOT EXISTS daily_fee_logs (
  id SERIAL PRIMARY KEY,
  order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  fee_amount INTEGER NOT NULL COMMENT '扣除的笔数',
  fee_reason VARCHAR(255) DEFAULT '24小时未使用' COMMENT '扣费原因',
  last_usage_time TIMESTAMP WITH TIME ZONE COMMENT '最后使用时间',
  fee_time TIMESTAMP WITH TIME ZONE DEFAULT NOW() COMMENT '扣费时间',
  remaining_before INTEGER NOT NULL COMMENT '扣费前剩余笔数',
  remaining_after INTEGER NOT NULL COMMENT '扣费后剩余笔数',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 添加索引
CREATE INDEX idx_daily_fee_logs_order_id ON daily_fee_logs(order_id);
CREATE INDEX idx_daily_fee_logs_fee_time ON daily_fee_logs(fee_time DESC);

-- 添加表注释
COMMENT ON TABLE daily_fee_logs IS '占费记录表，记录每次占费扣除的详细信息';
```

### 3.4 Price_Configs表扩展

```sql
-- 扩展价格配置表，添加笔数套餐相关配置
ALTER TABLE price_configs ADD COLUMN IF NOT EXISTS daily_fee INTEGER DEFAULT 1 
  COMMENT '每日占费笔数';
ALTER TABLE price_configs ADD COLUMN IF NOT EXISTS single_transaction_energy INTEGER DEFAULT 32000 
  COMMENT '单笔交易所需能量';
ALTER TABLE price_configs ADD COLUMN IF NOT EXISTS energy_check_interval INTEGER DEFAULT 30 
  COMMENT '能量检查间隔(秒)';
ALTER TABLE price_configs ADD COLUMN IF NOT EXISTS daily_fee_check_time TIME DEFAULT '00:00:00' 
  COMMENT '每日占费检查时间';
```

## 4. API接口设计

### 4.1 RESTful API规范

#### 4.1.1 订单相关接口

```typescript
// POST /api/orders/transaction-package
// 创建笔数套餐订单
interface CreateTransactionPackageOrderRequest {
  priceConfigId: number;        // 价格配置ID
  targetAddress: string;        // 能量接收地址
  transactionCount: number;     // 购买笔数
}

interface CreateTransactionPackageOrderResponse {
  success: boolean;
  data: {
    orderId: number;
    orderNumber: string;
    paymentAddress: string;
    paymentAmount: string;
    expiresAt: string;
    confirmationMessage: string;
  };
}

// GET /api/orders/transaction-package/:orderId/status
// 查询订单状态
interface OrderStatusResponse {
  success: boolean;
  data: {
    orderId: number;
    status: string;
    paymentStatus: string;
    transactionCount: number;
    usedTransactions: number;
    remainingTransactions: number;
    lastEnergyUsageTime?: string;
  };
}
```

#### 4.1.2 能量监听接口

```typescript
// POST /api/energy/monitor/start
// 启动能量监听
interface StartEnergyMonitorRequest {
  orderId: number;
  address: string;
}

// POST /api/energy/monitor/stop
// 停止能量监听
interface StopEnergyMonitorRequest {
  orderId: number;
}

// GET /api/energy/usage-logs/:orderId
// 获取能量使用记录
interface EnergyUsageLogsResponse {
  success: boolean;
  data: {
    logs: Array<{
      id: number;
      energyBefore: number;
      energyAfter: number;
      energyConsumed: number;
      usageTime: string;
      transactionHash?: string;
    }>;
    total: number;
  };
}
```

#### 4.1.3 分批代理接口

```typescript
// POST /api/delegation/batch/execute
// 执行分批代理
interface ExecuteBatchDelegationRequest {
  orderId: number;
  energyAmount?: number;  // 可选，默认使用配置值
}

interface ExecuteBatchDelegationResponse {
  success: boolean;
  data: {
    delegationTxHash: string;
    energyAmount: number;
    remainingTransactions: number;
  };
}
```

### 4.2 WebSocket实时通信

```typescript
// WebSocket事件定义
interface WebSocketEvents {
  // 能量使用检测事件
  'energy:usage-detected': {
    orderId: number;
    energyConsumed: number;
    remainingEnergy: number;
  };
  
  // 代理执行事件
  'delegation:executed': {
    orderId: number;
    txHash: string;
    energyAmount: number;
    remainingTransactions: number;
  };
  
  // 占费扣除事件
  'daily-fee:deducted': {
    orderId: number;
    feeAmount: number;
    remainingTransactions: number;
  };
}
```

## 5. 核心服务实现细节

### 5.1 BatchDelegationController实现

```typescript
/**
 * 分批代理控制器
 * 负责管理笔数套餐的分批能量代理逻辑
 */
export class BatchDelegationController {
  constructor(
    private orderService: OrderService,
    private energyDelegationService: EnergyDelegationService,
    private tronService: TronService,
    private notificationService: NotificationService,
    private logger: Logger
  ) {}

  /**
   * 执行单笔能量代理
   * @param orderId 订单ID
   * @param energyAmount 代理能量数量（可选）
   */
  async delegateSingleTransaction(orderId: number, energyAmount?: number): Promise<void> {
    const order = await this.orderService.findById(orderId);
    if (!order || order.orderType !== 'transaction_package') {
      throw new Error('Invalid order for batch delegation');
    }

    // 检查剩余笔数
    if (order.remainingTransactions <= 0) {
      throw new Error('No remaining transactions for delegation');
    }

    // 获取配置的单笔能量数量
    const priceConfig = await this.orderService.getPriceConfig(order.priceConfigId);
    const delegationAmount = energyAmount || priceConfig.singleTransactionEnergy;

    try {
      // 执行能量代理
      const delegationResult = await this.energyDelegationService.delegateEnergy({
        targetAddress: order.targetAddress,
        energyAmount: delegationAmount,
        duration: 3600 // 1小时
      });

      // 更新订单状态
      await this.updateTransactionCount(orderId, delegationResult.txHash);

      // 发送通知
      await this.notificationService.sendDelegationNotification(order, delegationResult);

      this.logger.info(`Batch delegation executed for order ${orderId}`, {
        txHash: delegationResult.txHash,
        energyAmount: delegationAmount,
        remainingTransactions: order.remainingTransactions - 1
      });

    } catch (error) {
      this.logger.error(`Batch delegation failed for order ${orderId}`, error);
      throw error;
    }
  }

  /**
   * 更新订单笔数状态
   * @param orderId 订单ID
   * @param delegationTxHash 代理交易哈希
   */
  async updateTransactionCount(orderId: number, delegationTxHash: string): Promise<void> {
    await this.orderService.updateOrder(orderId, {
      usedTransactions: { increment: 1 },
      remainingTransactions: { decrement: 1 },
      delegateTxHash: delegationTxHash,
      updatedAt: new Date()
    });

    // 检查是否完成所有笔数
    const updatedOrder = await this.orderService.findById(orderId);
    if (updatedOrder.remainingTransactions === 0) {
      await this.completeOrder(orderId);
    }
  }

  /**
   * 完成订单
   * @param orderId 订单ID
   */
  private async completeOrder(orderId: number): Promise<void> {
    await this.orderService.updateOrder(orderId, {
      status: 'completed',
      completedAt: new Date()
    });

    const order = await this.orderService.findById(orderId);
    await this.notificationService.sendOrderCompletionNotification(order);
  }

  /**
   * 检查订单完成状态
   * @param orderId 订单ID
   */
  async checkCompletionStatus(orderId: number): Promise<boolean> {
    const order = await this.orderService.findById(orderId);
    return order.remainingTransactions === 0;
  }
}
```

### 5.2 EnergyUsageMonitorService实现

```typescript
/**
 * 能量使用监听服务
 * 负责监听用户地址的能量变化，触发下一笔代理
 */
export class EnergyUsageMonitorService {
  private monitoringOrders = new Map<number, NodeJS.Timeout>();
  private readonly ENERGY_THRESHOLD = 10000; // 能量不足阈值

  constructor(
    private orderService: OrderService,
    private tronService: TronService,
    private batchDelegationController: BatchDelegationController,
    private energyUsageLogRepository: EnergyUsageLogRepository,
    private redisService: RedisService,
    private logger: Logger
  ) {}

  /**
   * 开始监听用户地址能量变化
   * @param address TRON地址
   * @param orderId 订单ID
   */
  async monitorEnergyUsage(address: string, orderId: number): Promise<void> {
    // 停止现有监听（如果存在）
    this.stopMonitoring(orderId);

    const order = await this.orderService.findById(orderId);
    if (!order || order.status !== 'processing') {
      return;
    }

    // 获取监听间隔配置
    const priceConfig = await this.orderService.getPriceConfig(order.priceConfigId);
    const checkInterval = (priceConfig.energyCheckInterval || 30) * 1000; // 转换为毫秒

    // 设置定时监听
    const timer = setInterval(async () => {
      try {
        await this.checkEnergyStatus(address, orderId);
      } catch (error) {
        this.logger.error(`Energy monitoring error for order ${orderId}`, error);
      }
    }, checkInterval);

    this.monitoringOrders.set(orderId, timer);
    this.logger.info(`Started energy monitoring for order ${orderId}, address ${address}`);
  }

  /**
   * 检查能量状态
   * @param address TRON地址
   * @param orderId 订单ID
   */
  private async checkEnergyStatus(address: string, orderId: number): Promise<void> {
    // 获取当前能量值
    const currentEnergy = await this.tronService.getAccountEnergy(address);
    
    // 从缓存获取上次能量值
    const cacheKey = `energy:${address}:${orderId}`;
    const lastEnergyStr = await this.redisService.get(cacheKey);
    const lastEnergy = lastEnergyStr ? parseInt(lastEnergyStr) : currentEnergy;

    // 检测能量消耗
    if (lastEnergy > currentEnergy) {
      const energyConsumed = lastEnergy - currentEnergy;
      
      // 记录能量使用
      await this.recordEnergyUsage(orderId, address, lastEnergy, currentEnergy, energyConsumed);
      
      // 更新订单最后使用时间
      await this.orderService.updateOrder(orderId, {
        lastEnergyUsageTime: new Date()
      });
    }

    // 检查是否需要代理下一笔
    if (currentEnergy < this.ENERGY_THRESHOLD) {
      await this.triggerNextDelegation(orderId);
    }

    // 更新缓存
    await this.redisService.set(cacheKey, currentEnergy.toString(), 3600); // 1小时过期
  }

  /**
   * 记录能量使用
   */
  private async recordEnergyUsage(
    orderId: number,
    address: string,
    energyBefore: number,
    energyAfter: number,
    energyConsumed: number
  ): Promise<void> {
    await this.energyUsageLogRepository.create({
      orderId,
      userAddress: address,
      energyBefore,
      energyAfter,
      energyConsumed,
      usageTime: new Date(),
      detectionTime: new Date()
    });

    this.logger.info(`Energy usage recorded for order ${orderId}`, {
      address,
      energyConsumed,
      remainingEnergy: energyAfter
    });
  }

  /**
   * 触发下一笔能量代理
   * @param orderId 订单ID
   */
  async triggerNextDelegation(orderId: number): Promise<void> {
    const order = await this.orderService.findById(orderId);
    if (!order || order.remainingTransactions <= 0) {
      this.stopMonitoring(orderId);
      return;
    }

    try {
      await this.batchDelegationController.delegateSingleTransaction(orderId);
      this.logger.info(`Next delegation triggered for order ${orderId}`);
    } catch (error) {
      this.logger.error(`Failed to trigger next delegation for order ${orderId}`, error);
    }
  }

  /**
   * 停止监听
   * @param orderId 订单ID
   */
  stopMonitoring(orderId: number): void {
    const timer = this.monitoringOrders.get(orderId);
    if (timer) {
      clearInterval(timer);
      this.monitoringOrders.delete(orderId);
      this.logger.info(`Stopped energy monitoring for order ${orderId}`);
    }
  }

  /**
   * 检测能量是否用完
   * @param address TRON地址
   */
  async checkEnergyDepletion(address: string): Promise<boolean> {
    const currentEnergy = await this.tronService.getAccountEnergy(address);
    return currentEnergy < this.ENERGY_THRESHOLD;
  }
}
```

### 5.3 DailyFeeService实现

```typescript
/**
 * 占费检测服务
 * 负责24小时占费机制的检测和执行
 */
export class DailyFeeService {
  constructor(
    private orderService: OrderService,
    private dailyFeeLogRepository: DailyFeeLogRepository,
    private notificationService: NotificationService,
    private logger: Logger
  ) {}

  /**
   * 检查24小时内是否有能量使用
   * @param orderId 订单ID
   */
  async checkEnergyUsageIn24Hours(orderId: number): Promise<boolean> {
    const order = await this.orderService.findById(orderId);
    if (!order || !order.lastEnergyUsageTime) {
      return false;
    }

    const now = new Date();
    const lastUsageTime = new Date(order.lastEnergyUsageTime);
    const hoursDiff = (now.getTime() - lastUsageTime.getTime()) / (1000 * 60 * 60);

    return hoursDiff < 24;
  }

  /**
   * 执行占费扣除
   * @param orderId 订单ID
   * @param feeAmount 扣费笔数
   */
  async deductDailyFee(orderId: number, feeAmount: number): Promise<void> {
    const order = await this.orderService.findById(orderId);
    if (!order || order.remainingTransactions <= 0) {
      return;
    }

    const actualFeeAmount = Math.min(feeAmount, order.remainingTransactions);
    const remainingBefore = order.remainingTransactions;
    const remainingAfter = remainingBefore - actualFeeAmount;

    // 更新订单剩余笔数
    await this.orderService.updateOrder(orderId, {
      remainingTransactions: remainingAfter,
      dailyFeeLastCheck: new Date(),
      updatedAt: new Date()
    });

    // 记录占费日志
    await this.dailyFeeLogRepository.create({
      orderId,
      feeAmount: actualFeeAmount,
      feeReason: '24小时未使用',
      lastUsageTime: order.lastEnergyUsageTime,
      feeTime: new Date(),
      remainingBefore,
      remainingAfter
    });

    // 发送通知
    await this.notificationService.sendDailyFeeNotification(order, actualFeeAmount, remainingAfter);

    // 检查是否需要完成订单
    if (remainingAfter === 0) {
      await this.orderService.updateOrder(orderId, {
        status: 'completed',
        completedAt: new Date()
      });
      await this.notificationService.sendOrderCompletionNotification(order);
    }

    this.logger.info(`Daily fee deducted for order ${orderId}`, {
      feeAmount: actualFeeAmount,
      remainingBefore,
      remainingAfter
    });
  }

  /**
   * 定时任务：每日占费检查
   */
  async scheduleDailyFeeCheck(): Promise<void> {
    try {
      // 查询所有活跃的笔数套餐订单
      const activeOrders = await this.orderService.findActiveTransactionPackageOrders();
      
      this.logger.info(`Starting daily fee check for ${activeOrders.length} orders`);

      for (const order of activeOrders) {
        try {
          // 检查是否需要占费
          const hasRecentUsage = await this.checkEnergyUsageIn24Hours(order.id);
          
          if (!hasRecentUsage) {
            // 获取占费配置
            const priceConfig = await this.orderService.getPriceConfig(order.priceConfigId);
            const dailyFee = priceConfig.dailyFee || 1;
            
            // 执行占费
            await this.deductDailyFee(order.id, dailyFee);
          } else {
            // 更新检查时间
            await this.orderService.updateOrder(order.id, {
              dailyFeeLastCheck: new Date()
            });
          }
        } catch (error) {
          this.logger.error(`Daily fee check failed for order ${order.id}`, error);
        }
      }

      this.logger.info('Daily fee check completed');
    } catch (error) {
      this.logger.error('Daily fee check process failed', error);
    }
  }

  /**
   * 启动定时任务调度
   */
  startScheduler(): void {
    // 每小时执行一次占费检查
    setInterval(() => {
      this.scheduleDailyFeeCheck();
    }, 60 * 60 * 1000); // 1小时

    this.logger.info('Daily fee scheduler started');
  }
}
```

## 6. 分阶段开发计划

### 6.1 阶段一：核心功能实现（第1-7天）

#### 6.1.1 数据库设计和迁移（第1-2天）
**负责人**: 后端开发工程师  
**工作量**: 2人日

**详细任务**:
- [ ] **Day 1**: 设计数据库表结构
  - 编写Orders表扩展SQL脚本
  - 设计Energy_Usage_Logs表结构
  - 设计Daily_Fee_Logs表结构
  - 扩展Price_Configs表字段
  - 创建数据库迁移脚本

- [ ] **Day 2**: 执行数据库迁移和测试
  - 在开发环境执行迁移脚本
  - 验证表结构和索引
  - 编写数据库操作的单元测试
  - 创建测试数据

**交付物**:
- 数据库迁移脚本
- 表结构文档
- 单元测试用例

#### 6.1.2 订单确认消息生成器（第2-3天）
**负责人**: 后端开发工程师  
**工作量**: 1.5人日

**详细任务**:
- [ ] **Day 2下午**: 设计消息模板
  - 分析用户需求的消息格式
  - 设计可配置的消息模板
  - 实现金额和地址的复制功能

- [ ] **Day 3**: 实现消息生成服务
  - 编写MessageFormatGenerator类
  - 集成订单信息和价格配置
  - 实现过期时间计算
  - 添加消息格式验证

**交付物**:
- MessageFormatGenerator服务
- 消息模板配置
- 单元测试

#### 6.1.3 分批代理控制器基础版本（第3-5天）
**负责人**: 后端开发工程师  
**工作量**: 2.5人日

**详细任务**:
- [ ] **Day 3下午**: 设计分批代理架构
  - 分析现有EnergyDelegationService
  - 设计BatchDelegationController接口
  - 定义代理执行流程

- [ ] **Day 4**: 实现核心代理逻辑
  - 编写delegateSingleTransaction方法
  - 实现订单状态更新逻辑
  - 添加事务处理和错误处理

- [ ] **Day 5**: 完善和测试
  - 实现订单完成检测
  - 添加重试机制
  - 编写集成测试
  - 性能优化

**交付物**:
- BatchDelegationController服务
- API接口实现
- 集成测试用例

#### 6.1.4 简单的能量使用检测（第5-7天）
**负责人**: 后端开发工程师  
**工作量**: 2人日

**详细任务**:
- [ ] **Day 5下午**: 设计能量检测机制
  - 分析TRON API调用方式
  - 设计缓存策略
  - 定义检测触发条件

- [ ] **Day 6**: 实现基础监听服务
  - 编写EnergyUsageMonitorService基础版本
  - 实现能量状态查询
  - 添加Redis缓存支持

- [ ] **Day 7**: 集成和测试
  - 集成分批代理触发逻辑
  - 添加监听启动/停止接口
  - 编写端到端测试

**交付物**:
- EnergyUsageMonitorService基础版本
- 能量检测API接口
- 端到端测试用例

#### 6.1.5 阶段一验收标准
- [ ] 数据库表结构正确创建，索引优化到位
- [ ] 订单确认消息格式符合用户需求
- [ ] 分批代理基本功能正常工作
- [ ] 能量使用检测能够触发下一笔代理
- [ ] 所有核心API接口可正常调用
- [ ] 单元测试覆盖率达到80%以上

### 6.2 阶段二：监听和占费机制（第8-12天）

#### 6.2.1 完整的能量使用监听服务（第8-10天）
**负责人**: 后端开发工程师  
**工作量**: 2.5人日

**详细任务**:
- [ ] **Day 8**: 优化监听机制
  - 实现高精度能量变化检测
  - 添加WebSocket实时通知
  - 优化TRON API调用频率

- [ ] **Day 9**: 完善数据记录
  - 实现详细的能量使用记录
  - 添加交易哈希关联
  - 实现使用统计功能

- [ ] **Day 10**: 性能优化和测试
  - 优化并发监听性能
  - 添加监听异常恢复机制
  - 压力测试和性能调优

**交付物**:
- 完整的EnergyUsageMonitorService
- WebSocket实时通知
- 性能测试报告

#### 6.2.2 占费检测和执行服务（第10-11天）
**负责人**: 后端开发工程师  
**工作量**: 1.5人日

**详细任务**:
- [ ] **Day 10下午**: 实现占费检测逻辑
  - 编写24小时使用检测算法
  - 实现占费配置读取
  - 添加占费计算逻辑

- [ ] **Day 11**: 完善占费执行
  - 实现占费扣除操作
  - 添加占费记录日志
  - 实现占费通知功能

**交付物**:
- DailyFeeService完整实现
- 占费检测API接口
- 占费记录查询功能

#### 6.2.3 定时任务调度系统（第11-12天）
**负责人**: 后端开发工程师  
**工作量**: 1人日

**详细任务**:
- [ ] **Day 11下午**: 设计任务调度架构
  - 选择任务调度框架
  - 设计任务配置和管理
  - 实现任务监控和日志

- [ ] **Day 12**: 实现和部署
  - 实现占费检查定时任务
  - 实现能量监听管理任务
  - 添加任务状态监控
  - 部署和测试

**交付物**:
- 定时任务调度系统
- 任务监控界面
- 部署文档

#### 6.2.4 阶段二验收标准
- [ ] 能量使用监听准确率达到99%以上
- [ ] 占费机制按配置正确执行
- [ ] 定时任务稳定运行，无遗漏
- [ ] WebSocket实时通知正常工作
- [ ] 系统能处理100个并发订单监听

### 6.3 阶段三：优化和完善（第13-15天）

#### 6.3.1 异常处理和重试机制（第13天）
**负责人**: 后端开发工程师  
**工作量**: 1人日

**详细任务**:
- [ ] **Day 13上午**: 设计异常处理策略
  - 分析可能的异常场景
  - 设计重试策略和退避算法
  - 实现异常恢复机制

- [ ] **Day 13下午**: 实现和测试
  - 添加代理失败重试逻辑
  - 实现监听服务异常恢复
  - 添加异常监控和告警

**交付物**:
- 异常处理机制
- 重试策略配置
- 异常监控系统

#### 6.3.2 用户通知优化（第13-14天）
**负责人**: 前端开发工程师  
**工作量**: 1.5人日

**详细任务**:
- [ ] **Day 13下午**: 优化Telegram Bot交互
  - 改进地址输入验证提示
  - 实现订单状态实时推送
  - 添加笔数使用进度通知

- [ ] **Day 14**: 完善通知功能
  - 实现多语言通知支持
  - 添加通知偏好设置
  - 优化通知消息格式

**交付物**:
- 优化的Telegram Bot交互
- 多语言通知系统
- 用户偏好设置

#### 6.3.3 管理后台界面（第14-15天）
**负责人**: 前端开发工程师  
**工作量**: 1.5人日

**详细任务**:
- [ ] **Day 14下午**: 设计管理界面
  - 设计笔数套餐订单管理页面
  - 设计占费记录查询界面
  - 设计能量使用统计图表

- [ ] **Day 15**: 实现和集成
  - 实现订单管理功能
  - 实现统计报表功能
  - 集成后端API接口
  - 用户体验优化

**交付物**:
- 笔数套餐管理界面
- 统计报表功能
- 用户操作手册

#### 6.3.4 阶段三验收标准
- [ ] 异常处理覆盖所有关键场景
- [ ] 用户通知体验良好，响应及时
- [ ] 管理后台功能完整，操作便捷
- [ ] 系统整体稳定性达到生产要求
- [ ] 文档完整，便于维护和扩展

### 6.4 依赖关系和里程碑

```
阶段一 (Day 1-7)
├── 数据库设计 (Day 1-2) ──┐
├── 消息生成器 (Day 2-3) ──┼── 基础功能完成 (Day 7)
├── 分批代理 (Day 3-5) ────┤
└── 能量检测 (Day 5-7) ────┘

阶段二 (Day 8-12)
├── 监听服务 (Day 8-10) ───┐
├── 占费机制 (Day 10-11) ──┼── 核心功能完成 (Day 12)
└── 定时任务 (Day 11-12) ──┘

阶段三 (Day 13-15)
├── 异常处理 (Day 13) ─────┐
├── 通知优化 (Day 13-14) ──┼── 系统完善 (Day 15)
└── 管理界面 (Day 14-15) ──┘
```

## 7. 技术风险评估和缓解策略

### 7.1 高风险项识别

#### 7.1.1 能量使用监听的实时性和准确性
**风险等级**: 高  
**影响**: 可能导致代理时机不准确，影响用户体验

**缓解策略**:
- **技术方案**: 采用多层检测机制
  - 主检测：30秒间隔的定时查询
  - 辅助检测：WebSocket实时事件监听
  - 备用检测：用户主动触发检测
- **数据一致性**: 使用Redis缓存 + 数据库双重存储
- **异常恢复**: 实现自动重连和状态恢复机制
- **监控告警**: 建立监听服务健康检查和异常告警

#### 7.1.2 分批代理的时机控制
**风险等级**: 高  
**影响**: 代理时机错误可能导致资源浪费或服务中断

**缓解策略**:
- **精确控制**: 基于能量阈值和使用模式的智能判断
- **防重复代理**: 使用分布式锁防止重复执行
- **状态同步**: 实时更新订单状态，确保数据一致性
- **回滚机制**: 代理失败时的自动回滚和重试

#### 7.1.3 占费机制的公平性和准确性
**风险等级**: 中  
**影响**: 不公平的占费可能导致用户投诉和信任问题

**缓解策略**:
- **精确计时**: 使用高精度时间戳记录使用时间
- **透明记录**: 详细记录每次占费的原因和计算过程
- **用户通知**: 占费前提前通知用户，提供申诉渠道
- **手动干预**: 提供管理员手动调整占费的功能

### 7.2 中风险项管理

#### 7.2.1 TRON网络API稳定性
**风险等级**: 中  
**影响**: API不稳定可能影响能量查询和代理执行

**缓解策略**:
- **多节点备份**: 配置多个TRON节点，实现自动切换
- **请求重试**: 实现指数退避的重试机制
- **缓存策略**: 合理使用缓存减少API调用频率
- **降级方案**: API异常时的服务降级策略

#### 7.2.2 数据库性能瓶颈
**风险等级**: 中  
**影响**: 大量订单监听可能导致数据库性能问题

**缓解策略**:
- **索引优化**: 为查询频繁的字段创建合适的索引
- **分表策略**: 考虑按时间或订单类型分表
- **读写分离**: 使用读写分离减轻主库压力
- **连接池管理**: 优化数据库连接池配置

### 7.3 低风险项监控

#### 7.3.1 内存使用和垃圾回收
**风险等级**: 低  
**影响**: 长时间运行可能导致内存泄漏

**缓解策略**:
- **内存监控**: 实时监控内存使用情况
- **定期重启**: 设置定期重启策略
- **代码审查**: 重点审查可能导致内存泄漏的代码

#### 7.3.2 日志存储空间
**风险等级**: 低  
**影响**: 大量日志可能占用过多存储空间

**缓解策略**:
- **日志轮转**: 配置日志文件自动轮转
- **压缩归档**: 定期压缩和归档历史日志
- **清理策略**: 设置日志自动清理策略

## 8. 测试策略和部署方案

### 8.1 测试策略

#### 8.1.1 单元测试
**覆盖率目标**: 80%以上  
**测试框架**: Jest + TypeScript

**重点测试模块**:
- BatchDelegationController的所有公共方法
- EnergyUsageMonitorService的核心逻辑
- DailyFeeService的计算逻辑
- 数据库操作的Repository层

**测试用例设计**:
```typescript
// 示例：分批代理控制器测试
describe('BatchDelegationController', () => {
  describe('delegateSingleTransaction', () => {
    it('should delegate energy successfully', async () => {
      // 测试正常代理流程
    });
    
    it('should throw error when no remaining transactions', async () => {
      // 测试剩余笔数为0的情况
    });
    
    it('should handle delegation failure', async () => {
      // 测试代理失败的处理
    });
  });
});
```

#### 8.1.2 集成测试
**测试环境**: Docker容器化测试环境  
**数据库**: PostgreSQL测试实例

**测试场景**:
- 完整的订单创建到完成流程
- 能量监听和自动代理流程
- 占费检测和扣除流程
- 异常情况的处理和恢复

#### 8.1.3 端到端测试
**测试工具**: Playwright + TypeScript  
**测试范围**: 从Telegram Bot交互到订单完成的完整流程

**关键测试用例**:
- 用户选择套餐并完成支付
- 能量使用后自动代理下一笔
- 24小时未使用触发占费
- 订单完成后的状态更新

#### 8.1.4 性能测试
**测试工具**: Artillery.js  
**测试指标**:
- 并发订单处理能力：目标100个并发订单
- API响应时间：平均响应时间<200ms
- 数据库查询性能：复杂查询<100ms
- 内存使用：长时间运行内存增长<10%

**测试场景**:
```yaml
# artillery配置示例
config:
  target: 'http://localhost:3001'
  phases:
    - duration: 60
      arrivalRate: 10
      name: "Warm up"
    - duration: 300
      arrivalRate: 50
      name: "Load test"
scenarios:
  - name: "Create transaction package order"
    requests:
      - post:
          url: "/api/orders/transaction-package"
          json:
            priceConfigId: 1
            targetAddress: "TRX_ADDRESS"
            transactionCount: 10
```

### 8.2 部署方案

#### 8.2.1 环境配置

**开发环境**:
- Node.js 18+
- PostgreSQL 14+
- Redis 6+
- Docker & Docker Compose

**生产环境**:
- 负载均衡：Nginx
- 应用服务：PM2集群模式
- 数据库：PostgreSQL主从复制
- 缓存：Redis Cluster
- 监控：Prometheus + Grafana

#### 8.2.2 部署流程

**阶段一部署**（基础功能）:
```bash
# 1. 数据库迁移
npm run migrate:up

# 2. 构建应用
npm run build

# 3. 启动服务
pm2 start ecosystem.config.js --env production

# 4. 验证部署
npm run test:integration
```

**阶段二部署**（监听和占费）:
```bash
# 1. 停止现有服务
pm2 stop all

# 2. 数据库迁移
npm run migrate:up

# 3. 更新配置
cp .env.production.new .env.production

# 4. 重启服务
pm2 restart all

# 5. 启动定时任务
npm run scheduler:start
```

**阶段三部署**（优化完善）:
```bash
# 1. 前端构建
npm run build:frontend

# 2. 后端更新
pm2 reload all

# 3. 验证功能
npm run test:e2e
```

#### 8.2.3 监控和告警

**系统监控指标**:
- CPU使用率：<70%
- 内存使用率：<80%
- 磁盘使用率：<85%
- 网络延迟：<50ms

**业务监控指标**:
- 订单创建成功率：>99%
- 代理执行成功率：>98%
- 能量监听准确率：>99%
- API响应时间：<200ms

**告警配置**:
```yaml
# Prometheus告警规则示例
groups:
  - name: transaction_package
    rules:
      - alert: HighOrderFailureRate
        expr: rate(order_creation_failures[5m]) > 0.01
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High order creation failure rate"
          
      - alert: EnergyMonitoringDown
        expr: up{job="energy-monitor"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Energy monitoring service is down"
```

#### 8.2.4 回滚策略

**自动回滚触发条件**:
- 错误率超过5%持续5分钟
- 响应时间超过1秒持续3分钟
- 服务不可用超过1分钟

**回滚步骤**:
```bash
# 1. 停止新版本服务
pm2 stop all

# 2. 恢复数据库（如需要）
psql -f backup/rollback_$(date +%Y%m%d).sql

# 3. 切换到上一版本
git checkout $(git describe --tags --abbrev=0 HEAD^)
npm install
npm run build

# 4. 启动服务
pm2 start ecosystem.config.js

# 5. 验证回滚
npm run test:smoke
```

### 8.3 上线检查清单

#### 8.3.1 技术检查
- [ ] 所有单元测试通过
- [ ] 集成测试通过
- [ ] 性能测试达标
- [ ] 安全扫描无高危漏洞
- [ ] 数据库迁移脚本验证
- [ ] 配置文件检查
- [ ] 日志配置正确
- [ ] 监控告警配置

#### 8.3.2 业务检查
- [ ] 订单创建流程正常
- [ ] 支付确认机制正常
- [ ] 分批代理逻辑正确
- [ ] 能量监听准确
- [ ] 占费机制公平
- [ ] 通知功能正常
- [ ] 管理界面可用

#### 8.3.3 运维检查
- [ ] 备份策略配置
- [ ] 监控系统正常
- [ ] 告警通知配置
- [ ] 日志收集正常
- [ ] 负载均衡配置
- [ ] SSL证书有效
- [ ] 防火墙规则正确

## 9. 总结

本技术实现分阶段执行计划为笔数套餐功能提供了完整的技术架构设计和实施方案。通过三个阶段的渐进式开发，确保系统的稳定性和可维护性：

**第一阶段**专注于核心功能的实现，建立坚实的技术基础；  
**第二阶段**完善监听和占费机制，实现完整的业务逻辑；  
**第三阶段**优化用户体验和系统稳定性，达到生产就绪状态。

整个实施过程严格遵循技术风险控制原则，通过完善的测试策略和部署方案，确保系统的高可用性和数据安全性。同时，详细的监控和告警机制为系统的长期稳定运行提供保障。

**关键成功因素**:
1. **严格按照分阶段计划执行**，确保每个阶段的交付质量
2. **重视测试和质量保证**，建立完善的测试体系
3. **做好风险管控**，提前识别和缓解技术风险
4. **保持技术文档更新**，便于后续维护和扩展
5. **建立有效的监控体系**，确保系统稳定运行

通过本计划的实施，笔数套餐功能将成为TRON能量租赁系统的重要组成部分，为用户提供更加灵活和精确的能量代理服务。