import { Router } from 'express';
import { query } from '../database';
import { energyPoolService } from '../services/energy-pool';
import { tronService } from '../services/tron/TronService';

const router: Router = Router();

/**
 * è·å–èƒ½é‡æ± æ¦‚è§ˆä¿¡æ¯
 * GET /api/energy-pool
 */
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, network_id } = req.query;
    
    // è·å–èƒ½é‡æ± ç»Ÿè®¡ä¿¡æ¯
    const statistics = await energyPoolService.getPoolStatistics();
    
    // è·å–è´¦æˆ·åˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µå’Œç½‘ç»œè¿‡æ»¤ï¼‰
    const accounts = await energyPoolService.getAllPoolAccounts();
    
    // ç”±äºå·²ç§»é™¤network_idå­—æ®µï¼Œä¸å†è¿›è¡Œç½‘ç»œè¿‡æ»¤
    let filteredAccounts = accounts;
    
    // åˆ†é¡µå¤„ç†
    const pageNum = parseInt(page as string) || 1;
    const limitNum = parseInt(limit as string) || 10;
    const offset = (pageNum - 1) * limitNum;
    const paginatedAccounts = filteredAccounts.slice(offset, offset + limitNum);
    
    // éšè—ç§é’¥ä¿¡æ¯
    const safeAccounts = paginatedAccounts.map(account => ({
      ...account,
      private_key_encrypted: '***'
    }));
    
    res.json({
      success: true,
      data: {
        statistics: statistics.success ? statistics.data : null,
        accounts: safeAccounts,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total: filteredAccounts.length,
          totalPages: Math.ceil(filteredAccounts.length / limitNum)
        }
      },
      message: 'Energy pool data retrieved successfully'
    });
  } catch (error) {
    console.error('Get energy pool overview error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get energy pool overview'
    });
  }
});

/**
 * ä½¿ç”¨TronGrid APIè·å–USDTä½™é¢ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰
 */
async function getUSDTBalanceFromTronGrid(address: string, rpcUrl: string, contractAddress: string): Promise<{ success: boolean; balance: number; error?: string }> {
  try {
    const axios = (await import('axios')).default;
    
    // æ„å»ºTronGrid APIç«¯ç‚¹
    let gridApiUrl;
    if (rpcUrl.includes('shasta')) {
      gridApiUrl = 'https://api.shasta.trongrid.io';
    } else if (rpcUrl.includes('nile')) {
      gridApiUrl = 'https://nile.trongrid.io';
    } else {
      gridApiUrl = 'https://api.trongrid.io';
    }
    
    console.log('ğŸŒ [TronGrid] ä½¿ç”¨TronGrid APIæŸ¥è¯¢USDTä½™é¢:', { address, contractAddress, gridApiUrl });
    
    // ä½¿ç”¨v1 APIè·å–è´¦æˆ·å®Œæ•´ä¿¡æ¯ï¼ŒåŒ…å«TRC20ä½™é¢  
    const response = await axios.get(`${gridApiUrl}/v1/accounts/${address}`, {
      headers: {
        'TRON-PRO-API-KEY': process.env.TRON_API_KEY || ''
      },
      timeout: 10000
    });
    
    console.log('ğŸ“Š [TronGrid] TronGrid v1 APIå“åº”:', JSON.stringify(response.data, null, 2));
    
    if (response.data && response.data.success && response.data.data && response.data.data.length > 0) {
      const accountData = response.data.data[0];
      
      // æŸ¥æ‰¾TRC20ä½™é¢
      if (accountData.trc20 && Array.isArray(accountData.trc20)) {
        for (const trc20Token of accountData.trc20) {
          // trc20Tokenæ˜¯å¯¹è±¡ï¼Œé”®æ˜¯åˆçº¦åœ°å€ï¼Œå€¼æ˜¯ä½™é¢
          if (trc20Token[contractAddress]) {
            const balance = Number(trc20Token[contractAddress]) / Math.pow(10, 6); // USDT 6ä½å°æ•°
            console.log('âœ… [TronGrid] æ‰¾åˆ°USDTä½™é¢:', balance);
            return { success: true, balance: balance };
          }
        }
      }
      
      console.log('â„¹ï¸ [TronGrid] æœªæ‰¾åˆ°æŒ‡å®šUSDTåˆçº¦çš„ä½™é¢');
      return { success: true, balance: 0 };
    }
    
    console.log('âš ï¸ [TronGrid] TronGrid APIå“åº”æ ¼å¼å¼‚å¸¸');
    return { success: false, balance: 0, error: 'TronGrid API response invalid' };
    
  } catch (error) {
    console.error('âŒ [TronGrid] TronGrid APIè°ƒç”¨å¤±è´¥:', error.message);
    return { success: false, balance: 0, error: error.message };
  }
}

/**
 * ä»æ•°æ®åº“è·å–æŒ‡å®šç½‘ç»œçš„USDTåˆçº¦åœ°å€é…ç½®
 * @param networkId - ç½‘ç»œID
 * @returns åˆçº¦åœ°å€ä¿¡æ¯
 */
async function getNetworkUSDTContract(networkId: string): Promise<{ 
  address: string | null; 
  decimals: number;
  symbol?: string;
  type?: string;
  name?: string;
}> {
  try {
    console.log('ğŸ” [Contract] è·å–ç½‘ç»œåˆçº¦åœ°å€:', networkId);
    
    const contractResult = await query(
      'SELECT * FROM get_network_contract_address($1, $2)',
      [networkId, 'USDT']
    );
    
    if (contractResult.rows.length > 0) {
      const contract = contractResult.rows[0];
      console.log('âœ… [Contract] æ‰¾åˆ°USDTåˆçº¦:', {
        address: contract.address,
        decimals: contract.decimals,
        symbol: contract.symbol,
        type: contract.type,
        name: contract.name
      });
      return {
        address: contract.address,
        decimals: contract.decimals || 6,
        symbol: contract.symbol || 'USDT',
        type: contract.type || 'TRC20',
        name: contract.name || 'USDT'
      };
    }
    
    console.warn('âš ï¸ [Contract] æœªæ‰¾åˆ°ç½‘ç»œUSDTåˆçº¦åœ°å€:', networkId);
    return { address: null, decimals: 6, symbol: 'USDT', type: 'TRC20', name: 'USDT' };
  } catch (error) {
    console.error('âŒ [Contract] è·å–ç½‘ç»œåˆçº¦åœ°å€å¤±è´¥:', error);
    return { address: null, decimals: 6, symbol: 'USDT', type: 'TRC20', name: 'USDT' };
  }
}

/**
 * æ–°ç‰ˆUSDTä½™é¢è·å–å‡½æ•° - ä»æ•°æ®åº“è·å–åˆçº¦åœ°å€é…ç½®
 * @param address - TRONè´¦æˆ·åœ°å€
 * @param networkId - ç½‘ç»œID
 */
async function getUSDTBalanceFromDatabase(address: string, networkId: string): Promise<{ success: boolean; balance: number; error?: string }> {
  try {
    console.log('ğŸ” [USDT Balance New] å¼€å§‹è·å–USDTä½™é¢:', { address, networkId });
    
    // è·å–ç½‘ç»œä¿¡æ¯
    const networkResult = await query(
      'SELECT name, network_type, rpc_url FROM tron_networks WHERE id = $1 AND is_active = true',
      [networkId]
    );
    
    if (networkResult.rows.length === 0) {
      return {
        success: false,
        balance: 0,
        error: 'Network not found or inactive'
      };
    }
    
    const network = networkResult.rows[0];
    
    // è·å–USDTåˆçº¦åœ°å€é…ç½®
    const usdtContract = await getNetworkUSDTContract(networkId);
    if (!usdtContract.address) {
      console.warn('âš ï¸ [USDT Balance New] USDTåˆçº¦åœ°å€æœªé…ç½®ï¼Œè¿”å›0ä½™é¢');
      return {
        success: true,
        balance: 0,
        error: `USDT contract not configured for network: ${network.name}`
      };
    }
    
    console.log('âœ… [USDT Balance New] ä½¿ç”¨æ•°æ®åº“é…ç½®:', {
      networkName: network.name,
      contractAddress: usdtContract.address,
      decimals: usdtContract.decimals
    });
    
    // ä½¿ç”¨TronGrid APIè·å–ä½™é¢
    return await getUSDTBalanceFromTronGrid(address, network.rpc_url, usdtContract.address);
    
  } catch (error) {
    console.error('âŒ [USDT Balance New] è·å–USDTä½™é¢å¤±è´¥:', error);
    return {
      success: false,
      balance: 0,
      error: error.message
    };
  }
}

/**
 * è·å–USDTä½™é¢çš„å‡½æ•°
 */
async function getUSDTBalance(address: string, rpcUrl: string): Promise<{ success: boolean; balance: number; error?: string }> {
  try {
    console.log('ğŸ” [USDT Balance] å¼€å§‹è·å–USDTä½™é¢:', { address, rpcUrl });
    
    // ä½¿ç”¨ESæ¨¡å—æ–¹å¼å¯¼å…¥TronWeb
    const tronWebModule = await import('tronweb');
    
    // è·å–æ­£ç¡®çš„TronWebæ„é€ å‡½æ•°
    let TronWeb;
    if (typeof tronWebModule.default === 'function') {
      TronWeb = tronWebModule.default;
    } else if (typeof tronWebModule.TronWeb === 'function') {
      TronWeb = tronWebModule.TronWeb;
    } else {
      console.error('âŒ [USDT Balance] TronWebå¯¼å…¥å¤±è´¥:', {
        defaultType: typeof tronWebModule.default,
        TronWebType: typeof tronWebModule.TronWeb,
        keys: Object.keys(tronWebModule)
      });
      return {
        success: true, // ä¸å½±å“ä¸»æµç¨‹
        balance: 0,
        error: "TronWeb library not available"
      };
    }
    
    console.log('âœ… [USDT Balance] TronWebå¯¼å…¥æˆåŠŸ');
    
    // åˆ›å»ºTronWebå®ä¾‹
    const tronWeb = new TronWeb({
      fullHost: rpcUrl,
      headers: { "TRON-PRO-API-KEY": process.env.TRON_API_KEY || '' }
    });
    
    // éªŒè¯åœ°å€æ ¼å¼
    if (!tronWeb.isAddress(address)) {
      console.error('âŒ [USDT Balance] æ— æ•ˆçš„TRONåœ°å€:', address);
      return {
        success: false,
        balance: 0,
        error: 'Invalid TRON address'
      };
    }
    
    // æ ¹æ®ç½‘ç»œç±»å‹é€‰æ‹©USDTåˆçº¦åœ°å€
    let usdtContractAddress;
    if (rpcUrl.includes('shasta')) {
      // Shastaæµ‹è¯•ç½‘USDTåˆçº¦ (ä½¿ç”¨å¸¸è§çš„æµ‹è¯•USDTåˆçº¦)
      usdtContractAddress = 'TLBaRhANQoJFTqre9Nf1mjuwNWjCJeYqUL';
      console.log('ğŸŒ [USDT Balance] ä½¿ç”¨Shastaæµ‹è¯•ç½‘USDTåˆçº¦');
    } else if (rpcUrl.includes('nile')) {
      // Nileæµ‹è¯•ç½‘USDTåˆçº¦ (å®é™…ä½¿ç”¨çš„USDTåˆçº¦åœ°å€)
      usdtContractAddress = 'TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf'; 
      console.log('ğŸŒ [USDT Balance] ä½¿ç”¨Nileæµ‹è¯•ç½‘USDTåˆçº¦');
    } else {
      // ä¸»ç½‘USDTåˆçº¦
      usdtContractAddress = 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t';
      console.log('ğŸŒ [USDT Balance] ä½¿ç”¨ä¸»ç½‘USDTåˆçº¦');
    }
    
    try {
      // è·å–åˆçº¦å®ä¾‹
      const contract = await tronWeb.contract().at(usdtContractAddress);
      console.log('âœ… [USDT Balance] åˆçº¦å®ä¾‹åˆ›å»ºæˆåŠŸ');
      
      // è°ƒç”¨ balanceOf æ–¹æ³•è·å–ä½™é¢
      const balance = await contract.balanceOf(address).call();
      console.log('ğŸ“Š [USDT Balance] åŸå§‹ä½™é¢æ•°æ®:', balance);
      
      // USDTæœ‰6ä½å°æ•°ï¼Œéœ€è¦é™¤ä»¥10^6
      let usdtBalance = 0;
      if (balance) {
        if (typeof balance.toNumber === 'function') {
          usdtBalance = balance.toNumber() / Math.pow(10, 6);
        } else if (typeof balance === 'string' || typeof balance === 'number') {
          usdtBalance = Number(balance) / Math.pow(10, 6);
        } else if (balance._hex) {
          usdtBalance = parseInt(balance._hex, 16) / Math.pow(10, 6);
        } else if (balance.toString) {
          usdtBalance = Number(balance.toString()) / Math.pow(10, 6);
        }
      }
      
      console.log('âœ… [USDT Balance] è®¡ç®—åçš„USDTä½™é¢:', usdtBalance);
      
      return {
        success: true,
        balance: usdtBalance
      };
      
    } catch (contractError) {
      console.error('âŒ [USDT Balance] åˆçº¦è°ƒç”¨å¤±è´¥:', contractError.message);
      
      // å¯¹äºæµ‹è¯•ç½‘ç»œï¼Œä½¿ç”¨TronGrid APIä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
      if (rpcUrl.includes('shasta') || rpcUrl.includes('nile')) {
        console.log('ğŸ“ [USDT Balance] åˆçº¦è°ƒç”¨å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨TronGrid APIæŸ¥è¯¢æµ‹è¯•ç½‘USDTä½™é¢');
        try {
          const gridBalance = await getUSDTBalanceFromTronGrid(address, rpcUrl, usdtContractAddress);
          if (gridBalance.success) {
            return gridBalance;
          }
        } catch (gridError) {
          console.error('âŒ [USDT Balance] TronGrid APIä¹Ÿå¤±è´¥äº†:', gridError);
        }
        
        // å¦‚æœæ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥ï¼Œè¿”å›0ä½™é¢ä½†ä¸æ˜¾ç¤ºé”™è¯¯ï¼ˆæµ‹è¯•ç½‘ç»œå¯èƒ½ç¡®å®æ²¡æœ‰USDTä½™é¢ï¼‰
        console.log('ğŸ“ [USDT Balance] æµ‹è¯•ç½‘ç»œUSDTæŸ¥è¯¢å¤±è´¥ï¼Œè¿”å›0ä½™é¢');
        return {
          success: true,
          balance: 0
        };
      }
      
      throw contractError;
    }
    
  } catch (error) {
    console.error('âŒ [USDT Balance] è·å–USDTä½™é¢å¤±è´¥:', {
      address,
      rpcUrl,
      error: error.message,
      stack: error.stack
    });
    
    return {
      success: true, // ä¸å½±å“ä¸»æµç¨‹
      balance: 0,
      error: `USDT balance unavailable: ${error.message}`
    };
  }
}

/**
 * è·å–èƒ½é‡æ± ç»Ÿè®¡ä¿¡æ¯
 */
router.get('/statistics', async (req, res) => {
  try {
    const result = await energyPoolService.getPoolStatistics();
    if (result.success) {
      res.json({
        success: true,
        data: result.data
      });
    } else {
      res.status(500).json({
        success: false,
        message: result.message || 'Failed to get pool statistics'
      });
    }
  } catch (error) {
    console.error('Get pool statistics error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get pool statistics'
    });
  }
});

/**
 * è·å–ä»Šæ—¥æ¶ˆè€—ç»Ÿè®¡
 */
router.get('/today-consumption', async (req, res) => {
  try {
    const consumption = await energyPoolService.getTodayConsumption();
    res.json({
      success: true,
      data: consumption
    });
  } catch (error) {
    console.error('è·å–ä»Šæ—¥æ¶ˆè€—ç»Ÿè®¡å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'è·å–ä»Šæ—¥æ¶ˆè€—ç»Ÿè®¡å¤±è´¥'
    });
  }
});

/**
 * è·å–æ‰€æœ‰èƒ½é‡æ± è´¦æˆ·ï¼ˆåŒ…æ‹¬å·²åœç”¨çš„ï¼‰
 * æ‰€æœ‰è´¦æˆ·æ”¯æŒæ‰€æœ‰ç½‘ç»œï¼Œä¸å†æŒ‰ç½‘ç»œè¿‡æ»¤
 * ä¿ç•™network_idå‚æ•°ç”¨äºå…¼å®¹æ€§ï¼Œä½†ä¸å½±å“è¿”å›ç»“æœ
 */
router.get('/accounts', async (req, res) => {
  try {
    const { network_id } = req.query;
    
    console.log('ğŸ” [EnergyPool] è·å–è´¦æˆ·åˆ—è¡¨ï¼Œå½“å‰ç½‘ç»œ:', network_id || 'æœªæŒ‡å®š');
    
    const accounts = await energyPoolService.getAllPoolAccounts();
    
    // è´¦æˆ·ç½‘ç»œæ— å…³æ€§ï¼šæ‰€æœ‰è´¦æˆ·éƒ½æ”¯æŒæ‰€æœ‰ç½‘ç»œ
    // ä¸å†æŒ‰network_idè¿‡æ»¤ï¼Œè¿”å›æ‰€æœ‰å¯ç”¨è´¦æˆ·
    console.log(`ğŸ” [EnergyPool] è¿”å›æ‰€æœ‰è´¦æˆ·: ${accounts.length} ä¸ªè´¦æˆ·ï¼ˆæ”¯æŒæ‰€æœ‰ç½‘ç»œï¼‰`);
    
    // éšè—ç§é’¥ä¿¡æ¯
    const safeAccounts = accounts.map(account => ({
      ...account,
      private_key_encrypted: '***'
    }));
    
    res.json({
      success: true,
      data: safeAccounts
    });
  } catch (error) {
    console.error('Get pool accounts error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get pool accounts'
    });
  }
});

/**
 * è·å–å¯ç”¨çš„TRONç½‘ç»œåˆ—è¡¨
 */
router.get('/networks', async (req, res) => {
  try {
    console.log('ğŸŒ [EnergyPool] è·å–å¯ç”¨ç½‘ç»œåˆ—è¡¨');
    
    const sql = `
      SELECT id, name, network_type, rpc_url, is_active, health_status, config
      FROM tron_networks 
      WHERE is_active = true 
      ORDER BY 
        CASE WHEN network_type = 'mainnet' THEN 1 ELSE 2 END,
        name
    `;
    
    const result = await query(sql);
    const networks = result.rows.map(network => ({
      id: network.id,
      name: network.name,
      type: network.network_type,
      rpc_url: network.rpc_url,
      is_active: network.is_active,
      health_status: network.health_status,
      config: network.config // åŒ…å«åˆçº¦åœ°å€é…ç½®ä¿¡æ¯
    }));
    
    console.log(`ğŸŒ [EnergyPool] è¿”å› ${networks.length} ä¸ªå¯ç”¨ç½‘ç»œ`);
    
    res.json({
      success: true,
      data: networks
    });
  } catch (error) {
    console.error('Get networks error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get networks'
    });
  }
});

/**
 * è·å–ç‰¹å®šèƒ½é‡æ± è´¦æˆ·è¯¦æƒ…
 */
router.get('/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { include_private_key } = req.query;
    
    const account = await energyPoolService.getPoolAccountById(id);
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Pool account not found'
      });
    }
    
    // æ ¹æ®æŸ¥è¯¢å‚æ•°å†³å®šæ˜¯å¦éšè—ç§é’¥ä¿¡æ¯
    let responseAccount;
    if (include_private_key === 'true') {
      // ç¼–è¾‘æ¨¡å¼ï¼šè¿”å›çœŸå®ç§é’¥
      console.log('ğŸ”’ [EnergyPool] ç¼–è¾‘æ¨¡å¼ï¼šè¿”å›å®Œæ•´è´¦æˆ·ä¿¡æ¯ï¼ˆåŒ…å«ç§é’¥ï¼‰');
      responseAccount = account;
    } else {
      // æ™®é€šæŸ¥çœ‹æ¨¡å¼ï¼šéšè—ç§é’¥
      responseAccount = {
        ...account,
        private_key_encrypted: '***'
      };
    }
    
    res.json({
      success: true,
      data: responseAccount
    });
  } catch (error) {
    console.error('Get pool account error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get pool account'
    });
  }
});

/**
 * åˆ·æ–°èƒ½é‡æ± çŠ¶æ€
 */
router.post('/refresh', async (req, res) => {
  try {
    await energyPoolService.refreshPoolStatus();
    res.json({
      success: true,
      message: 'Pool status refreshed successfully'
    });
  } catch (error) {
    console.error('Refresh pool status error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to refresh pool status'
    });
  }
});

/**
 * ä¼˜åŒ–èƒ½é‡åˆ†é…
 */
router.post('/optimize', async (req, res) => {
  try {
    const { requiredEnergy } = req.body;
    
    if (!requiredEnergy || requiredEnergy <= 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid required energy amount'
      });
    }
    
    const result = await energyPoolService.optimizeEnergyAllocation(requiredEnergy);
    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error('Optimize energy allocation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to optimize energy allocation'
    });
  }
});

/**
 * é¢„ç•™èƒ½é‡èµ„æº
 */
router.post('/reserve', async (req, res) => {
  try {
    const { accountId, energyAmount } = req.body;
    
    if (!accountId || !energyAmount || energyAmount <= 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid accountId or energyAmount'
      });
    }
    
    // ç”Ÿæˆäº¤æ˜“ID
    const transactionId = `reserve_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    await energyPoolService.reserveEnergy(accountId, energyAmount, transactionId);
    
    res.json({
      success: true,
      message: 'Energy reserved successfully',
      transactionId
    });
  } catch (error) {
    console.error('Reserve energy error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to reserve energy'
    });
  }
});

/**
 * é‡Šæ”¾é¢„ç•™çš„èƒ½é‡èµ„æº
 */
router.post('/release', async (req, res) => {
  try {
    const { accountId, energyAmount } = req.body;
    
    if (!accountId || !energyAmount || energyAmount <= 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid accountId or energyAmount'
      });
    }
    
    // ç”Ÿæˆäº¤æ˜“ID
    const transactionId = `release_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    await energyPoolService.releaseReservedEnergy(accountId, energyAmount, transactionId);
    
    res.json({
      success: true,
      message: 'Reserved energy released successfully',
      transactionId
    });
  } catch (error) {
    console.error('Release energy error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to release reserved energy'
    });
  }
});

/**
 * ç¡®è®¤èƒ½é‡ä½¿ç”¨
 */
router.post('/confirm-usage', async (req, res) => {
  try {
    const { accountId, energyAmount } = req.body;
    
    if (!accountId || !energyAmount || energyAmount <= 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid accountId or energyAmount'
      });
    }
    
    // ç”Ÿæˆäº¤æ˜“ID
    const transactionId = `confirm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    await energyPoolService.confirmEnergyUsage(accountId, energyAmount, transactionId);
    
    res.json({
      success: true,
      message: 'Energy usage confirmed successfully',
      transactionId
    });
  } catch (error) {
    console.error('Confirm energy usage error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to confirm energy usage'
    });
  }
});

/**
 * éªŒè¯TRONåœ°å€å¹¶è·å–è´¦æˆ·ä¿¡æ¯
 */
router.post('/accounts/validate-address', async (req, res) => {
  try {
    const { address, private_key, network_id } = req.body;
    
    console.log('ğŸ” [ValidateAddress] æ¥æ”¶åˆ°éªŒè¯è¯·æ±‚:', {
      address,
      private_key: private_key ? `${private_key.substring(0, 8)}...` : 'undefined',
      network_id,
      timestamp: new Date().toISOString()
    });
    
    if (!address) {
      console.log('âŒ [ValidateAddress] åœ°å€ä¸ºç©º');
      return res.status(400).json({
        success: false,
        message: 'TRONåœ°å€ä¸èƒ½ä¸ºç©º'
      });
    }

    if (!network_id) {
      console.log('âŒ [ValidateAddress] ç½‘ç»œIDä¸ºç©º');
      return res.status(400).json({
        success: false,
        message: 'è¯·å…ˆé€‰æ‹©TRONç½‘ç»œ'
      });
    }
    
    // è·å–ç½‘ç»œé…ç½®
    console.log('ğŸ” [ValidateAddress] æŸ¥è¯¢ç½‘ç»œé…ç½®:', network_id);
    const networkResult = await query(
      'SELECT name, network_type, rpc_url, is_active, health_status FROM tron_networks WHERE id = $1',
      [network_id]
    );
    
    console.log('ğŸ” [ValidateAddress] ç½‘ç»œæŸ¥è¯¢ç»“æœ:', {
      found: networkResult.rows.length > 0,
      network: networkResult.rows[0] || null
    });
    
    if (networkResult.rows.length === 0) {
      console.log('âŒ [ValidateAddress] ç½‘ç»œä¸å­˜åœ¨');
      return res.status(400).json({
        success: false,
        message: 'æŒ‡å®šçš„ç½‘ç»œä¸å­˜åœ¨'
      });
    }
    
    const network = networkResult.rows[0];
    
    if (!network.is_active) {
      console.log('âŒ [ValidateAddress] ç½‘ç»œæœªæ¿€æ´»:', network.name);
      return res.status(400).json({
        success: false,
        message: `ç½‘ç»œ ${network.name} å½“å‰ä¸å¯ç”¨`
      });
    }
    
    // éªŒè¯åœ°å€æ ¼å¼
    console.log('ğŸ” [ValidateAddress] å¼€å§‹éªŒè¯åœ°å€æ ¼å¼:', address);
    try {
      const isValidAddress = tronService.isValidAddress(address);
      console.log('ğŸ” [ValidateAddress] åœ°å€éªŒè¯ç»“æœ:', isValidAddress);
      
      if (!isValidAddress) {
        console.log('âŒ [ValidateAddress] åœ°å€æ ¼å¼æ— æ•ˆ');
        return res.status(400).json({
          success: false,
          message: 'æ— æ•ˆçš„TRONåœ°å€æ ¼å¼'
        });
      }
    } catch (error) {
      console.error('âŒ [ValidateAddress] åœ°å€éªŒè¯æŠ›å‡ºå¼‚å¸¸:', error);
      return res.status(400).json({
        success: false,
        message: `åœ°å€éªŒè¯å¤±è´¥: ${error.message}`
      });
    }
    
    // éªŒè¯ç§é’¥æ ¼å¼ï¼ˆå¦‚æœæä¾›ï¼‰
    if (private_key) {
      console.log('ğŸ” [ValidateAddress] éªŒè¯ç§é’¥æ ¼å¼:', `${private_key.substring(0, 8)}...`);
      if (!/^[0-9a-fA-F]{64}$/.test(private_key)) {
        console.log('âŒ [ValidateAddress] ç§é’¥æ ¼å¼æ— æ•ˆ');
        return res.status(400).json({
          success: false,
          message: 'æ— æ•ˆçš„ç§é’¥æ ¼å¼ï¼ˆéœ€è¦64ä½åå…­è¿›åˆ¶å­—ç¬¦ï¼‰'
        });
      }
      console.log('âœ… [ValidateAddress] ç§é’¥æ ¼å¼éªŒè¯é€šè¿‡');
    }
    
    // åˆ›å»ºåŸºäºæŒ‡å®šç½‘ç»œçš„TronServiceå®ä¾‹
    console.log('ğŸ” [ValidateAddress] åˆ›å»ºç½‘ç»œä¸“ç”¨TronServiceå®ä¾‹:', {
      rpcUrl: network.rpc_url,
      networkName: network.name,
      hasPrivateKey: !!private_key
    });
    
    let networkTronService;
    try {
      const { TronService } = await import('../services/tron/TronService');
      networkTronService = new TronService({
        fullHost: network.rpc_url,
        privateKey: private_key,
        solidityNode: network.rpc_url,
        eventServer: network.rpc_url
      });
      console.log('âœ… [ValidateAddress] TronServiceå®ä¾‹åˆ›å»ºæˆåŠŸ');
    } catch (error) {
      console.error('âŒ [ValidateAddress] åˆ›å»ºTronServiceå¤±è´¥:', error);
      return res.status(400).json({
        success: false,
        message: `åˆå§‹åŒ–TRONæœåŠ¡å¤±è´¥: ${error.message}`
      });
    }
    
    // è·å–è´¦æˆ·èµ„æºä¿¡æ¯
    console.log('ğŸ” [ValidateAddress] å¼€å§‹è·å–è´¦æˆ·ä¿¡æ¯...');
    const [accountInfo, resourceInfo, usdtBalance] = await Promise.all([
      networkTronService.getAccount(address),
      networkTronService.getAccountResources(address),
      getUSDTBalanceFromDatabase(address, network_id)
    ]);
    
    console.log('ğŸ” [ValidateAddress] è´¦æˆ·ä¿¡æ¯è·å–ç»“æœ:', {
      accountSuccess: accountInfo?.success,
      resourceSuccess: resourceInfo?.success,
      usdtSuccess: usdtBalance?.success
    });
    
    if (!accountInfo.success) {
      return res.status(400).json({
        success: false,
        message: `è·å–è´¦æˆ·ä¿¡æ¯å¤±è´¥: ${accountInfo.error}`
      });
    }
    
    if (!resourceInfo.success) {
      return res.status(400).json({
        success: false,
        message: `è·å–è´¦æˆ·èµ„æºä¿¡æ¯å¤±è´¥: ${resourceInfo.error}`
      });
    }
    
    // è·å–åˆçº¦åœ°å€ä¿¡æ¯
    const contractInfo = await getNetworkUSDTContract(network_id);
    console.log('ğŸ” [ValidateAddress] è·å–åˆçº¦åœ°å€ä¿¡æ¯:', contractInfo);
    console.log('ğŸ” [ValidateAddress] å³å°†è¿”å›çš„contractInfo:', contractInfo.address ? {
      address: contractInfo.address,
      decimals: contractInfo.decimals,
      type: contractInfo.type || 'TRC20',
      symbol: contractInfo.symbol || 'USDT',
      name: contractInfo.name || 'USDT'
    } : null);
    
    // è®¡ç®—å•ä½æˆæœ¬ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼ŒåŸºäºé»˜è®¤å€¼ï¼‰
    const totalFrozen = accountInfo.data.frozen?.reduce((sum, f) => sum + (f.frozen_balance || 0), 0) || 0;
    const energyLimit = resourceInfo.data.energy.limit || 0;
    let costPerEnergy = 0.001; // é»˜è®¤æˆæœ¬
    
    if (totalFrozen > 0 && energyLimit > 0) {
      // åŸºäºå†»ç»“TRXè®¡ç®—æˆæœ¬ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
      costPerEnergy = (totalFrozen / 1000000) / energyLimit; // TRXè½¬æ¢ä¸ºSUNå¹¶è®¡ç®—
    }
    
    const result = {
      address: address,
      balance: accountInfo.data.balance || 0,
      usdtBalance: Number((usdtBalance.balance || 0).toFixed(6)), // ä¿è¯å…­ä½å°æ•°ï¼Œä¸USDTåˆçº¦ç²¾åº¦ä¸€è‡´
      energy: {
        total: energyLimit,
        available: resourceInfo.data.energy.available,
        used: resourceInfo.data.energy.used
      },
      bandwidth: {
        total: resourceInfo.data.bandwidth.limit || 0,
        available: resourceInfo.data.bandwidth.available || 0,
        used: resourceInfo.data.bandwidth.used || 0
      },
      frozenInfo: accountInfo.data.frozen || [],
      estimatedCostPerEnergy: Number(costPerEnergy.toFixed(6)), // ä¿è¯å…­ä½å°æ•°ç²¾åº¦
      contractInfo: contractInfo.address ? {
        address: contractInfo.address,
        decimals: contractInfo.decimals,
        type: contractInfo.type || 'TRC20',
        symbol: contractInfo.symbol || 'USDT',
        name: contractInfo.name || 'USDT'
      } : null,
      networkInfo: {
        id: network_id,
        name: network.name,
        type: network.network_type,
        rpcUrl: network.rpc_url
      },
      isValid: true,
      usdtInfo: usdtBalance.error ? { error: usdtBalance.error } : null // æ·»åŠ USDTé”™è¯¯ä¿¡æ¯
    };
    
    res.json({
      success: true,
      data: result,
      message: 'è´¦æˆ·éªŒè¯æˆåŠŸ'
    });
    
  } catch (error) {
    console.error('âŒ [ValidateAddress] éªŒè¯TRONåœ°å€å‡ºç°æœªæ•è·å¼‚å¸¸:', error);
    console.error('âŒ [ValidateAddress] å¼‚å¸¸è¯¦æƒ…:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    
    res.status(500).json({
      success: false,
      message: `éªŒè¯TRONåœ°å€å¤±è´¥: ${error.message}`
    });
  }
});

/**
 * æ·»åŠ æ–°çš„èƒ½é‡æ± è´¦æˆ·ï¼ˆè‡ªåŠ¨è·å–TRONæ•°æ®ï¼‰
 */
router.post('/accounts', async (req, res) => {
  try {
    const {
      name,
      tron_address,
      private_key_encrypted,
      account_type = 'own_energy',
      priority = 50,
      description,
      daily_limit,
      monthly_limit,
      status = 'active'
    } = req.body;
    
    // éªŒè¯å¿…éœ€å­—æ®µ
    if (!name || !tron_address || !private_key_encrypted) {
      return res.status(400).json({
        success: false,
        message: 'ç¼ºå°‘å¿…éœ€å­—æ®µ: name, tron_address, private_key_encrypted'
      });
    }
    
    // éªŒè¯TRONåœ°å€æ ¼å¼
    if (!tronService.isValidAddress(tron_address)) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„TRONåœ°å€æ ¼å¼'
      });
    }
    
    // éªŒè¯ç§é’¥æ ¼å¼
    if (!/^[0-9a-fA-F]{64}$/.test(private_key_encrypted)) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„ç§é’¥æ ¼å¼ï¼ˆéœ€è¦64ä½åå…­è¿›åˆ¶å­—ç¬¦ï¼‰'
      });
    }
    
    console.log(`ğŸ” [EnergyPool] å¼€å§‹è·å–TRONè´¦æˆ·ä¿¡æ¯: ${tron_address}`);
    
    // ä»TRONç½‘ç»œè·å–è´¦æˆ·ä¿¡æ¯
    const [accountInfo, resourceInfo] = await Promise.all([
      tronService.getAccount(tron_address),
      tronService.getAccountResources(tron_address)
    ]);
    
    if (!accountInfo.success) {
      console.log(`âŒ [EnergyPool] è·å–è´¦æˆ·ä¿¡æ¯å¤±è´¥: ${accountInfo.error}`);
      return res.status(400).json({
        success: false,
        message: `è·å–è´¦æˆ·ä¿¡æ¯å¤±è´¥: ${accountInfo.error}`
      });
    }
    
    if (!resourceInfo.success) {
      console.log(`âŒ [EnergyPool] è·å–èµ„æºä¿¡æ¯å¤±è´¥: ${resourceInfo.error}`);
      return res.status(400).json({
        success: false,
        message: `è·å–è´¦æˆ·èµ„æºä¿¡æ¯å¤±è´¥: ${resourceInfo.error}`
      });
    }
    
    // è®¡ç®—èƒ½é‡ç›¸å…³æ•°æ®
    const energyLimit = resourceInfo.data.energy.limit || 0;
    const availableEnergy = resourceInfo.data.energy.available || 0;
    
    // è®¡ç®—å•ä½æˆæœ¬
    const totalFrozen = accountInfo.data.frozen?.reduce((sum, f) => sum + (f.frozen_balance || 0), 0) || 0;
    let costPerEnergy = 0.001; // é»˜è®¤æˆæœ¬
    
    if (totalFrozen > 0 && energyLimit > 0) {
      // åŸºäºå†»ç»“TRXè®¡ç®—æˆæœ¬ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
      costPerEnergy = (totalFrozen / 1000000) / energyLimit;
    }
    
    console.log(`âœ… [EnergyPool] TRONè´¦æˆ·ä¿¡æ¯è·å–æˆåŠŸ:`, {
      total_energy: energyLimit,
      available_energy: availableEnergy,
      cost_per_energy: costPerEnergy
    });
    
    // åˆ›å»ºè´¦æˆ·æ•°æ®
    const accountData = {
      name: name.trim(),
      tron_address,
      private_key_encrypted,
      total_energy: energyLimit,
      available_energy: availableEnergy,
      reserved_energy: 0,
      total_bandwidth: resourceInfo.data.bandwidth.limit || 0,
      available_bandwidth: resourceInfo.data.bandwidth.available || 0,
      cost_per_energy: costPerEnergy,
      status,
      account_type,
      priority,
      description: description?.trim() || null,
      daily_limit,
      monthly_limit
    };
    
    console.log(`ğŸ’¾ [EnergyPool] å‡†å¤‡ä¿å­˜è´¦æˆ·æ•°æ®:`, accountData);
    
    const result = await energyPoolService.addPoolAccount(accountData);
    
    console.log(`ğŸ“ [EnergyPool] addPoolAccountç»“æœ:`, result);
    
    if (!result.success) {
      console.log(`âŒ [EnergyPool] ä¿å­˜åˆ°æ•°æ®åº“å¤±è´¥: ${result.message}`);
      return res.status(500).json({
        success: false,
        message: result.message
      });
    }
    
    const accountId = result.accountId;
    
    res.status(201).json({
      success: true,
      data: { 
        id: accountId,
        tronData: {
          total_energy: energyLimit,
          available_energy: availableEnergy,
          cost_per_energy: costPerEnergy,
          balance: accountInfo.data.balance,
          frozen_balance: totalFrozen
        }
      },
      message: 'èƒ½é‡æ± è´¦æˆ·æ·»åŠ æˆåŠŸï¼Œå·²è‡ªåŠ¨è·å–TRONç½‘ç»œæ•°æ®'
    });
  } catch (error) {
    console.error('Add pool account error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add pool account'
    });
  }
});

/**
 * ä¿®å¤ç§é’¥å ä½ç¬¦ï¼ˆç®¡ç†å‘˜ä¸“ç”¨ï¼‰
 */
router.post('/accounts/fix-private-keys', async (req, res) => {
  try {
    const { accounts } = req.body;
    
    if (!Array.isArray(accounts) || accounts.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'è¯·æä¾›è¦ä¿®å¤çš„è´¦æˆ·åˆ—è¡¨'
      });
    }
    
    const results = [];
    
    for (const account of accounts) {
      const { id, private_key_encrypted } = account;
      
      if (!id || !private_key_encrypted) {
        results.push({
          id,
          success: false,
          message: 'ç¼ºå°‘IDæˆ–ç§é’¥'
        });
        continue;
      }
      
      // éªŒè¯ç§é’¥æ ¼å¼
      if (!/^[0-9a-fA-F]{64}$/.test(private_key_encrypted)) {
        results.push({
          id,
          success: false,
          message: 'ç§é’¥æ ¼å¼æ— æ•ˆï¼ˆéœ€è¦64ä½åå…­è¿›åˆ¶ï¼‰'
        });
        continue;
      }
      
      try {
        const updateResult = await energyPoolService.updatePoolAccount(id, {
          private_key_encrypted: private_key_encrypted
        });
        
        results.push({
          id,
          success: updateResult.success,
          message: updateResult.message
        });
      } catch (error) {
        results.push({
          id,
          success: false,
          message: error.message
        });
      }
    }
    
    const successCount = results.filter(r => r.success).length;
    const failedCount = results.length - successCount;
    
    res.status(200).json({
      success: true,
      message: `ç§é’¥ä¿®å¤å®Œæˆï¼šæˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failedCount} ä¸ª`,
      data: {
        results,
        summary: {
          total: results.length,
          success: successCount,
          failed: failedCount
        }
      }
    });
    
  } catch (error) {
    console.error('ä¿®å¤ç§é’¥å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: 'ä¿®å¤ç§é’¥å¤±è´¥'
    });
  }
});

/**
 * æ›´æ–°èƒ½é‡æ± è´¦æˆ·
 */
router.put('/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    // ç§»é™¤ä¸å…è®¸æ›´æ–°çš„å­—æ®µ
    delete updates.id;
    delete updates.last_updated_at;
    delete updates.created_at;
    delete updates.updated_at;
    
    const success = await energyPoolService.updatePoolAccount(id, updates);
    
    if (success) {
      res.json({
        success: true,
        message: 'Pool account updated successfully'
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'Pool account not found'
      });
    }
  } catch (error) {
    console.error('Update pool account error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update pool account'
    });
  }
});

/**
 * å¯ç”¨è´¦æˆ·
 */
router.put('/accounts/:id/enable', async (req, res) => {
  try {
    const { id } = req.params;
    
    const updatedAccount = await energyPoolService.updatePoolAccount(id, { 
      status: 'active'
    });
    
    res.json({
      success: true,
      data: updatedAccount,
      message: 'è´¦æˆ·å·²å¯ç”¨'
    });
  } catch (error) {
    console.error('å¯ç”¨è´¦æˆ·å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'å¯ç”¨è´¦æˆ·å¤±è´¥'
    });
  }
});

/**
 * åœç”¨è´¦æˆ·
 */
router.put('/accounts/:id/disable', async (req, res) => {
  try {
    const { id } = req.params;
    
    const updatedAccount = await energyPoolService.updatePoolAccount(id, { 
      status: 'inactive'
    });
    
    res.json({
      success: true,
      data: updatedAccount,
      message: 'è´¦æˆ·å·²åœç”¨'
    });
  } catch (error) {
    console.error('åœç”¨è´¦æˆ·å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'åœç”¨è´¦æˆ·å¤±è´¥'
    });
  }
});

/**
 * æ‰¹é‡åœç”¨è´¦æˆ·
 */
router.put('/accounts/batch/disable', async (req, res) => {
  try {
    const { accountIds } = req.body;
    
    if (!Array.isArray(accountIds) || accountIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'è¯·æä¾›æœ‰æ•ˆçš„è´¦æˆ·IDåˆ—è¡¨'
      });
    }
    
    const results = await energyPoolService.batchUpdateAccounts(accountIds, { status: 'inactive' });
    
    res.json({
      success: true,
      data: results,
      message: `æˆåŠŸåœç”¨ ${results.successCount} ä¸ªè´¦æˆ·`
    });
  } catch (error) {
    console.error('æ‰¹é‡åœç”¨è´¦æˆ·å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'æ‰¹é‡åœç”¨è´¦æˆ·å¤±è´¥'
    });
  }
});

/**
 * æ‰¹é‡å¯ç”¨è´¦æˆ·
 */
router.put('/accounts/batch/enable', async (req, res) => {
  try {
    const { accountIds } = req.body;
    
    if (!Array.isArray(accountIds) || accountIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'è¯·æä¾›æœ‰æ•ˆçš„è´¦æˆ·IDåˆ—è¡¨'
      });
    }
    
    const results = await energyPoolService.batchUpdateAccounts(accountIds, { status: 'active' });
    
    res.json({
      success: true,
      data: results,
      message: `æˆåŠŸå¯ç”¨ ${results.successCount} ä¸ªè´¦æˆ·`
    });
  } catch (error) {
    console.error('æ‰¹é‡å¯ç”¨è´¦æˆ·å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'æ‰¹é‡å¯ç”¨è´¦æˆ·å¤±è´¥'
    });
  }
});

/**
 * åˆ é™¤è´¦æˆ·
 */
router.delete('/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const success = await energyPoolService.deletePoolAccount(id);
    
    if (success) {
      res.json({
        success: true,
        message: 'è´¦æˆ·å·²åˆ é™¤'
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'è´¦æˆ·ä¸å­˜åœ¨'
      });
    }
  } catch (error) {
    console.error('åˆ é™¤è´¦æˆ·å¤±è´¥:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'åˆ é™¤è´¦æˆ·å¤±è´¥'
    });
  }
});



export default router;