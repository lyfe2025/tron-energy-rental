# 数据库 N+1 查询优化清单

## 概述

本文档详细分析了项目中存在的数据库 N+1 查询问题，并提供具体的优化方案。N+1 查询问题是指：首先执行一个查询获取 N 条记录，然后为每条记录再执行一个查询，总共执行了 1+N 个查询，这会严重影响数据库性能。

**分析时间**: 2025-01-25  
**项目路径**: `/Volumes/wwx/dev/TronResourceDev/tron-energy-rental`  
**影响等级说明**:
- 🔴 **高危**: 严重影响性能，需要立即优化
- 🟡 **中等**: 有性能影响，建议优化
- 🟢 **低危**: 轻微影响，可考虑优化

---

## 🔴 高危问题列表

### 1. 能量预留服务 - 批量预留能量

**文件位置**: `api/services/energy-pool/EnergyReservationService.ts`  
**方法名**: `batchReserveEnergy`  
**代码行数**: 153-169行

**问题描述**:
```typescript
for (const reservation of reservations) {
  try {
    await this.reserveEnergy(
      reservation.poolAccountId,
      reservation.energyAmount,
      reservation.transactionId,
      reservation.userId
    );
    results.successCount++;
  } catch (error) {
    // 错误处理...
  }
}
```

**问题分析**:
- 在循环中逐个调用 `reserveEnergy` 方法
- 每次调用都会执行多个数据库查询（UPDATE + INSERT）
- 如果有 N 个预留请求，总共执行 1 + 2N 个查询

**优化方案**:
```typescript
async batchReserveEnergy(reservations: Array<{
  poolAccountId: string;
  energyAmount: number;
  transactionId: string;
  userId?: string;
}>): Promise<{
  successCount: number;
  failedCount: number;
  errors: Array<{ reservation: any; error: string }>;
  success: boolean;
}> {
  const results = {
    successCount: 0,
    failedCount: 0,
    errors: [] as Array<{ reservation: any; error: string }>,
    success: true
  };

  await query('BEGIN');
  
  try {
    // 1. 批量检查能量池状态
    const poolIds = reservations.map(r => r.poolAccountId);
    const poolCheckSql = `
      SELECT id, available_energy
      FROM energy_pools 
      WHERE id = ANY($1)
    `;
    const poolResult = await query(poolCheckSql, [poolIds]);
    const availableEnergy = new Map(
      poolResult.rows.map(row => [row.id, row.available_energy])
    );

    // 2. 验证所有预留请求
    const validReservations = [];
    for (const reservation of reservations) {
      const available = availableEnergy.get(reservation.poolAccountId) || 0;
      if (available >= reservation.energyAmount) {
        validReservations.push(reservation);
      } else {
        results.failedCount++;
        results.errors.push({
          reservation,
          error: '可用能量不足'
        });
      }
    }

    if (validReservations.length > 0) {
      // 3. 批量更新能量池
      const updateCases = validReservations.map((r, index) => 
        `WHEN id = $${index * 2 + 1} THEN available_energy - $${index * 2 + 2}`
      ).join(' ');
      
      const reservedCases = validReservations.map((r, index) => 
        `WHEN id = $${index * 2 + 1} THEN reserved_energy + $${index * 2 + 2}`
      ).join(' ');

      const updateParams = validReservations.flatMap(r => [r.poolAccountId, r.energyAmount]);
      const poolUpdateSql = `
        UPDATE energy_pools 
        SET 
          available_energy = CASE ${updateCases} ELSE available_energy END,
          reserved_energy = CASE ${reservedCases} ELSE reserved_energy END,
          updated_at = NOW()
        WHERE id = ANY($${updateParams.length + 1})
      `;
      
      await query(poolUpdateSql, [...updateParams, poolIds]);

      // 4. 批量插入消费日志
      if (validReservations.length > 0) {
        const logValues = validReservations.map((r, index) => 
          `(gen_random_uuid(), $${index * 6 + 1}, 'reserve', $${index * 6 + 2}, 0, $${index * 6 + 3}, $${index * 6 + 4}, $${index * 6 + 5}, NOW(), NOW())`
        ).join(', ');
        
        const logParams = validReservations.flatMap(r => [
          r.poolAccountId,
          r.energyAmount,
          r.transactionId,
          r.userId,
          `预留能量: ${r.energyAmount}`
        ]);

        const logSql = `
          INSERT INTO energy_consumption_logs (
            id, pool_account_id, transaction_type, energy_amount, 
            cost_amount, transaction_id, user_id, notes, created_at, updated_at
          ) VALUES ${logValues}
        `;
        
        await query(logSql, logParams);
      }

      results.successCount = validReservations.length;
    }

    await query('COMMIT');
    results.success = results.failedCount === 0;
    
  } catch (error) {
    await query('ROLLBACK');
    results.success = false;
    results.failedCount = reservations.length;
  }
  
  return results;
}
```

**预期性能提升**: 
- 原来：1 + 2N 个查询（N个预留请求）
- 优化后：4 个查询（固定数量）
- 提升幅度：当 N=100 时，从 201 个查询降低到 4 个查询，**提升 98%**

---

### 2. 能量预留服务 - 清理过期预留

**文件位置**: `api/services/energy-pool/EnergyReservationService.ts`  
**方法名**: `cleanupExpiredReservations`  
**代码行数**: 263-275行

**问题描述**:
```typescript
// 释放过期的预留能量
for (const expired of expiredResult.rows) {
  const energyAmount = parseInt(expired.expired_energy);
  
  await this.releaseReservedEnergy(
    expired.pool_account_id,
    energyAmount,
    `cleanup_${Date.now()}`,
    'system'
  );
  
  releasedCount++;
  totalEnergyReleased += energyAmount;
}
```

**问题分析**:
- 在循环中逐个调用 `releaseReservedEnergy` 方法
- 每次调用执行 UPDATE + INSERT 查询
- N 个过期记录需要 2N 个查询

**优化方案**:
```typescript
async cleanupExpiredReservations(expirationHours: number = 24): Promise<{
  releasedCount: number;
  totalEnergyReleased: number;
}> {
  try {
    const expirationTime = new Date(Date.now() - expirationHours * 60 * 60 * 1000);
    
    // 查找过期的预留记录
    const findExpiredSql = `
      SELECT DISTINCT pool_account_id, SUM(energy_amount) as expired_energy
      FROM energy_consumption_logs
      WHERE transaction_type = 'reserve' 
        AND created_at < $1
        AND transaction_id NOT IN (
          SELECT DISTINCT transaction_id 
          FROM energy_consumption_logs 
          WHERE transaction_type IN ('confirm', 'release')
            AND transaction_id IS NOT NULL
        )
      GROUP BY pool_account_id
    `;
    
    const expiredResult = await query(findExpiredSql, [expirationTime]);
    
    if (expiredResult.rows.length === 0) {
      return { releasedCount: 0, totalEnergyReleased: 0 };
    }

    const expiredRecords = expiredResult.rows.map(row => ({
      poolAccountId: row.pool_account_id,
      energyAmount: parseInt(row.expired_energy)
    }));

    const releasedCount = expiredRecords.length;
    const totalEnergyReleased = expiredRecords.reduce((sum, record) => sum + record.energyAmount, 0);

    await query('BEGIN');

    try {
      // 批量更新能量池
      const updateCases = expiredRecords.map((record, index) => 
        `WHEN id = $${index * 2 + 1} THEN available_energy + $${index * 2 + 2}`
      ).join(' ');
      
      const reservedCases = expiredRecords.map((record, index) => 
        `WHEN id = $${index * 2 + 1} THEN reserved_energy - $${index * 2 + 2}`
      ).join(' ');

      const updateParams = expiredRecords.flatMap(r => [r.poolAccountId, r.energyAmount]);
      const poolIds = expiredRecords.map(r => r.poolAccountId);
      
      const poolUpdateSql = `
        UPDATE energy_pools 
        SET 
          available_energy = CASE ${updateCases} ELSE available_energy END,
          reserved_energy = CASE ${reservedCases} ELSE reserved_energy END,
          updated_at = NOW()
        WHERE id = ANY($${updateParams.length + 1})
      `;
      
      await query(poolUpdateSql, [...updateParams, poolIds]);

      // 批量插入释放日志
      const timestamp = Date.now();
      const logValues = expiredRecords.map((record, index) => 
        `(gen_random_uuid(), $${index * 5 + 1}, 'release', $${index * 5 + 2}, 0, $${index * 5 + 3}, 'system', $${index * 5 + 4}, NOW(), NOW())`
      ).join(', ');
      
      const logParams = expiredRecords.flatMap(record => [
        record.poolAccountId,
        record.energyAmount,
        `cleanup_${timestamp}`,
        `系统清理过期预留: ${record.energyAmount}`
      ]);

      const logSql = `
        INSERT INTO energy_consumption_logs (
          id, pool_account_id, transaction_type, energy_amount, 
          cost_amount, transaction_id, user_id, notes, created_at, updated_at
        ) VALUES ${logValues}
      `;
      
      await query(logSql, logParams);

      await query('COMMIT');

      console.log(`批量清理过期预留完成: 释放 ${releasedCount} 个账户，总能量 ${totalEnergyReleased}`);

      return { releasedCount, totalEnergyReleased };
      
    } catch (error) {
      await query('ROLLBACK');
      throw error;
    }
    
  } catch (error) {
    console.error('清理过期预留失败:', error);
    throw new Error('清理过期预留失败');
  }
}
```

**预期性能提升**:
- 原来：1 + 2N 个查询
- 优化后：3 个查询
- 提升幅度：当 N=50 时，从 101 个查询降低到 3 个查询，**提升 97%**

---

### 3. 账户管理服务 - 批量更新账户

**文件位置**: `api/services/energy-pool/AccountManagementService.ts`  
**方法名**: `batchUpdateAccounts`  
**代码行数**: 148-172行

**问题描述**:
```typescript
for (const accountId of accountIds) {
  try {
    const sql = `
      UPDATE energy_pools 
      SET ${fields.join(', ')}, last_updated_at = NOW()
      WHERE id = $${paramIndex}
    `;
    
    const updateValues = [...values, accountId];
    const result = await query(sql, updateValues);
    
    if (result.rowCount > 0) {
      results.successCount++;
    } else {
      results.failedCount++;
      results.errors.push({ id: accountId, error: 'Account not found' });
    }
  } catch (error) {
    // 错误处理...
  }
}
```

**问题分析**:
- 在循环中逐个执行 UPDATE 查询
- N 个账户需要 N 个 UPDATE 查询

**优化方案**:
```typescript
async batchUpdateAccounts(accountIds: string[], updates: Partial<EnergyPoolAccount>): Promise<{ 
  successCount: number; 
  failedCount: number; 
  errors: Array<{ id: string; error: string }>;
  success: boolean;
  message: string;
}> {
  const results = {
    successCount: 0,
    failedCount: 0,
    errors: [] as Array<{ id: string; error: string }>,
    success: true,
    message: ''
  };

  try {
    // 构建动态更新字段
    const updateFields = Object.keys(updates).filter(key => updates[key] !== undefined);
    
    if (updateFields.length === 0) {
      results.success = false;
      results.message = 'No fields to update';
      return results;
    }

    await query('BEGIN');

    try {
      // 1. 检查哪些账户存在
      const checkSql = 'SELECT id FROM energy_pools WHERE id = ANY($1)';
      const existingResult = await query(checkSql, [accountIds]);
      const existingIds = existingResult.rows.map(row => row.id);
      const notFoundIds = accountIds.filter(id => !existingIds.includes(id));

      // 记录不存在的账户
      notFoundIds.forEach(id => {
        results.failedCount++;
        results.errors.push({ id, error: 'Account not found' });
      });

      if (existingIds.length > 0) {
        // 2. 批量更新存在的账户
        const setClause = updateFields.map((field, index) => 
          `${field} = $${index + 2}`
        ).join(', ');
        
        const values = updateFields.map(field => updates[field]);
        
        const batchUpdateSql = `
          UPDATE energy_pools 
          SET ${setClause}, last_updated_at = NOW()
          WHERE id = ANY($1)
        `;

        await query(batchUpdateSql, [existingIds, ...values]);
        results.successCount = existingIds.length;
      }

      await query('COMMIT');
      
      results.message = `批量更新完成: 成功 ${results.successCount} 个，失败 ${results.failedCount} 个`;
      results.success = results.failedCount === 0;
      
    } catch (error) {
      await query('ROLLBACK');
      throw error;
    }
    
  } catch (error) {
    console.error('Failed to batch update accounts:', error);
    results.success = false;
    results.message = 'Batch update failed';
    results.failedCount = accountIds.length;
  }
  
  return results;
}
```

**预期性能提升**:
- 原来：N 个 UPDATE 查询
- 优化后：2 个查询（CHECK + UPDATE）
- 提升幅度：当 N=100 时，从 100 个查询降低到 2 个查询，**提升 98%**

---

## 🟡 中等风险问题

### 4. 代理商订单查询

**文件位置**: `api/services/agent.ts`  
**方法名**: `getAgentOrders`  
**代码行数**: 218-242行

**现状分析**:
代码已经使用了 JOIN 查询和 `Promise.all` 并行执行，这是好的优化实践：
```typescript
const [dataResult, countResult] = await Promise.all([
  pool.query(query, values),
  pool.query(countQuery, values.slice(0, -2))
]);
```

**建议优化**:
- 考虑添加适当的数据库索引
- 如果查询频繁，可考虑添加缓存

### 5. 用户订单历史查询

**文件位置**: `api/services/user.ts`  
**方法名**: `getUserOrders`, `getUserBalanceHistory`  
**代码行数**: 237-291行

**现状分析**:
同样已经使用了优化的查询模式，使用 `Promise.all` 并行执行数据查询和总数统计。

---

## 🟢 已优化的良好实践

项目中已经有很多好的优化实践，值得继续保持：

### 1. 系统日志统计
**文件**: `api/routes/system/logs/controllers/LogsStatsController.ts`
- 大量使用 LEFT JOIN 避免 N+1 查询
- 使用 `Promise.all` 并行执行多个统计查询

### 2. 管理员角色查询
**文件**: `api/services/admin/AdminRoleService.ts`
- 复杂的权限查询使用了多表 JOIN
- 避免了在循环中查询权限信息

### 3. 监控服务
**文件**: `api/services/monitoring/*`
- 系统监控查询使用了批量查询和 Promise.all
- 避免了逐个查询系统状态

---

## 总体优化建议

### 1. 立即执行的优化
1. **优先修复高危问题**: 重点优化 `EnergyReservationService` 和 `AccountManagementService` 中的批量操作
2. **添加数据库索引**: 为经常查询的字段添加复合索引
3. **启用查询日志**: 监控慢查询，识别更多潜在问题

### 2. 中长期优化策略
1. **引入查询构建器**: 考虑使用 QueryBuilder 或 ORM 来更好地管理复杂查询
2. **实现查询缓存**: 对频繁查询的数据添加缓存层
3. **数据库连接池优化**: 调整连接池大小和超时设置

### 3. 监控和预防措施
1. **性能监控**: 设置数据库查询监控告警
2. **代码审查规范**: 在代码审查中重点关注循环中的查询操作
3. **自动化测试**: 添加性能测试，确保查询性能不退化

### 4. 建议的数据库索引

```sql
-- 能量消耗日志查询优化
CREATE INDEX idx_energy_consumption_logs_pool_transaction ON energy_consumption_logs(pool_account_id, transaction_type, created_at);
CREATE INDEX idx_energy_consumption_logs_transaction_id ON energy_consumption_logs(transaction_id) WHERE transaction_id IS NOT NULL;

-- 能量池查询优化
CREATE INDEX idx_energy_pools_status ON energy_pools(status, account_type);

-- 用户代理关系优化
CREATE INDEX idx_users_agent_id ON users(agent_id) WHERE agent_id IS NOT NULL;

-- 订单查询优化
CREATE INDEX idx_orders_user_status ON orders(user_id, status, created_at);

-- 管理员角色权限优化
CREATE INDEX idx_admin_roles_admin_id ON admin_roles(admin_id, role_id);
CREATE INDEX idx_role_permissions_role_id ON role_permissions(role_id, menu_id);
```

---

## 实施计划

### 第一阶段（高优先级）- 预计 2-3 天
- [ ] 修复 `EnergyReservationService.batchReserveEnergy` 方法
- [ ] 修复 `EnergyReservationService.cleanupExpiredReservations` 方法
- [ ] 修复 `AccountManagementService.batchUpdateAccounts` 方法
- [ ] 添加相关数据库索引

### 第二阶段（中优先级）- 预计 1-2 天
- [ ] 代码审查其他服务文件，确认无遗漏问题
- [ ] 实施数据库查询性能监控
- [ ] 编写性能测试用例

### 第三阶段（持续优化）
- [ ] 定期审查新增代码的查询模式
- [ ] 优化查询缓存策略
- [ ] 持续监控和调优数据库性能

---

## 验证方法

### 1. 性能测试
```bash
# 测试批量预留能量性能（修复前后对比）
curl -X POST http://localhost:3001/api/energy/batch-reserve \
  -H "Content-Type: application/json" \
  -d '{"reservations": [/* 100个预留请求 */]}'
```

### 2. 数据库查询监控
```sql
-- 监控查询执行计数
SELECT query, calls, total_time, mean_time 
FROM pg_stat_statements 
WHERE query LIKE '%energy_pools%'
ORDER BY total_time DESC;
```

### 3. 应用级监控
在应用中添加查询计数器，监控优化前后的查询数量变化。

---

**文档版本**: v1.0  
**最后更新**: 2025-01-25  
**审核状态**: 待审核  
**负责人**: AI 助手
